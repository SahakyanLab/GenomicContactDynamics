################################################################################
# Reduce ranges in ContactMxGap files (generated by B1_contactMxGap.R) to easily
# identify unmappable areas persistent across tissues
################################################################################
# FLAGS * FLAGS * FLAGS * FLAGS * FLAGS * FLAGS * FLAGS * FLAGS * FLAGS * FLAGS
### DIRECTORY STRUCTURE ########################################################
whorunsit = "LiezelMac" # "LiezelMac", "LiezelCluster", "LiezelLinuxDesk",
# "AlexMac", "AlexCluster"

if( !is.null(whorunsit[1]) ){
  # This can be expanded as needed ...
  if(whorunsit == "LiezelMac"){
    lib = "/Users/ltamon/DPhil/lib"
    wk.dir = "/Users/ltamon/DPhil/GenomicContactDynamics/21_Simulation"
  } else {
    stop("The supplied <whorunsit> option is not created in the script.", quote=FALSE)
  }
}
data.dir = paste0(wk.dir, "/out_contactMxGap")
out.dir = paste0(wk.dir, "/out_reduceContactMxGap")
### OTHER SETTINGS #############################################################
gcb = "min2Mb"
chr.v = paste0("chr", c(1:22, "X"))
metric = "Cs.norm"
out.id = "whole"
ct.v = sort(c("Co", "Hi", "Lu", "LV", "RV", "Ao", "PM", "Pa", "Sp", "Li", "SB", 
              "AG", "Ov", "Bl", "MesC", "MSC", "NPC", "TLC", "ESC", "FC", "LC"))
################################################################################
# LIBRARIES & DEPENDENCIES * LIBRARIES & DEPENDENCIES * LIBRARIES & DEPENDENCIES 
################################################################################
library(GenomicRanges)
source(paste0(lib, "/TrantoRextr/GEN_WhichOverlap.R"))
################################################################################
# MAIN CODE * MAIN CODE * MAIN CODE * MAIN CODE * MAIN CODE * MAIN CODE *
################################################################################
for(chr in chr.v){
  
  data.name <- paste(gcb, chr, out.id, metric, sep="_")
  x <- read.csv(file=paste0(data.dir, "/", data.name, "_contactMxGap.csv"), 
                row.names="X")
  if( any(duplicated(x)) ){
    stop(paste0(chr, ": Duplicated rows."))
  }
  
  x <- x[order(x$width, x$ct, decreasing=T),]
  
  # Convert x to GRanges
  xred <- makeGRangesFromDataFrame(df=x, keep.extra.columns=F, ignore.strand=T, 
                                   seqinfo=NULL, seqnames.field="seqnames",
                                   start.field="start", end.field="end",
                                   starts.in.df.are.0based=F)
  
  # Merge overlapping ranges in x; min.gapwidth=0L means consecutive ranges e.g. 1-5 and 6-7
  # not merged, contrary to default behavior of GenomicRanges::reduce.
  # min.gapwidth - Ranges separated by a gap of at least min.gapwidth positions are not merged.
  xred <- GenomicRanges::reduce(x=xred, ignore.strand=T, min.gapwidth=0L)
  xred <- as.data.frame(xred)
  
  # Assign x ranges to xred ranges
  hits.mx <- WhichOverlap(start.query=x$start, end.query=x$end, space.query=x$seqnames,
                          start.subject=xred$start, end.subject=xred$end,
                          space.subject=xred$seqnames, maxgap=-1L, minoverlap=1L,
                          type="within")
                 
  # Check that all x ranges matched and with only 1 xred range
  if( !identical(1:length(x[,1]), hits.mx[,"query"]) ){
    stop(paste0(chr, ": Checkpoint 1."))
  }
  
  x$red.end <- x$red.start <- NA
  x[hits.mx[,"query"],c("red.start", "red.end")] <- xred[hits.mx[,"subject"], 
                                                         c("start", "end")]
  x$red.width <- x$red.end-x$red.start+1
  
  if( any(is.na(x$red.width)) ){
    stop(paste0(chr, ": Checkpoint 2."))
  }
  
  write.csv(x, file=paste0(out.dir, "/", data.name, "_contactMxGap_reduced.csv"), 
            row.names=TRUE)
  
  print(paste0(chr, " done!"), quote=F)
  
  rm(chr, x, xred, hits.mx, data.name); gc()
  
}

# rm(list=ls()); gc()


#gr2 <- GRanges(seqnames="chr1",
#               ranges=IRanges(c(7, 10, 19), width=c(3,4,5)),
#               strand=c("*", "*", "*"), score=3:5, GC=c(0.3, 0.5, 0.66))
